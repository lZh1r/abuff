/// Prints provided arguments to the standard output.
/// If more than 1 argument is provided, they will be separated by commas:
/// ```
/// print(1,2,3);
/// // output: 1, 2, 3
/// ```
///
/// Any value can be printed using this function:
/// ```
/// let a = {
///     b: 2
/// };
/// print(a);
/// // output: { b: 2 }
/// ```
/// 
/// In case of all functions and closures a string "closure" will be printed:
/// ```
/// fun f() {1;};
/// print(f);
/// // output: closure
/// ```
///
/// Printing native functions will give more information
/// in form of this function's name and its module path:
/// ```
/// print(print);
/// // output: native function "print" from "std/builtins"
/// ```
export native fun print(...args: Any[]);

/// Returns program's uptime in nanoseconds.
/// Can be used for benchmarking performance:
/// ```
/// let start = clock();
/// // run some heavy function
/// heavy();
/// let end = clock();
/// print(end - start);
/// ```
export native fun clock(): Int;

/// Returns a length of an object (if applicable).
/// Supports: strings, arrays.
/// ```
/// let a = [1,2,3];
/// len(a); // 3
/// ```
export native fun len<T>(obj: T): Int;

/// Attempts to read contents of a file into a string.
export native fun readfile(path: String): Result<String>;

/// Attempts to write content to a file.
/// On success the file's content will be overwritten with provided content.
/// If the file does not exist it will get created.
export native fun writefile(path: String, content: String): Result<Void>;

/// Finishes execution as a failure with some message
export native fun panic(reason: String);

/// Asserts that an expression is true, otherwise panics
/// ```
/// let a = 9;
/// let b = 2;
/// assert(a % b == 0, "Oopsie!") // panics and prints "Oopsie"
/// ```
export fun assert(expression: Bool, reason: String) {
    if (!expression) panic(reason)
}

/// Enum representing optional values.
/// Used where a value may or may not be present.
/// Can be unwrapped via pattern matching or methods (wip).
export enum Option<T> {
    Some: T,
    None
} impl {
    fun intoResult(): Result<T> {
        match self {
            .Some(value) -> Result.Ok(value),
            .None(_) -> Result.Err({message: "the value is not provided"})
        }
    }
};

/// Constructs an Option.Some of type T.
/// Used as a shorthand for Option.Some().
export fun Some<T>(value: T): Option<T> {
    Option.Some(value)
}

/// Constructs an Option.None of type Any.
/// Used as a shorthand for Option.None().
export fun None<T>(): Option<T> {
    Option.None()
}

export type Error = {
    message: String
};

export enum Result<T> {
    Ok: T,
    Err: Error
} impl {
    fun isOk(): Bool {
        match self {
            .Ok(_) -> true,
            .Err(_) -> false
        }
    }
};
